/*
 * Please name our PokÃ©mon ðŸ‘ !
 *
 * Declare a string variable playerName
 */
let playerName = "Pikachu";

//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................

/*
 * Now, let's display our pokemon level !
 *
 * Define a playerLevel int variable
 */
let playerLevel = 20 * 2;

//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................

/*
 * We need to display a start message now ðŸ™ˆ
 * > Beware, sometimes our enemy is just plain evil and we should
 *  display that... ðŸ¦¹â€â™€ï¸
 * > A typical message is "Beware ! A wild * appears !"
 *
 * Please define getInitialBattleMessage with following signature ->
 *  (enemyName: string, isEnemyEvil: boolean): string
 */
let getInitialBattleMessage = (enemyName, isEnemyEvil) => {
  let enemyName =
    if (isEnemyEvil) {
      "Evil " ++ enemyName;
    } else {
      enemyName;
    };

  "Beware ! A wild " ++ enemyName ++ " appears !";
};

//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................

/*
 * How come we can not choose an attack ?
 * We need to implement a way to move our cursor ðŸ¤”
 *
 * Our possibilities are: Up ðŸ‘†, Right ðŸ‘‰, Down ðŸ‘‡ and Left ðŸ‘ˆ
 *
 * Implement getNextCursorPosition function with following signature
 *  (currentAttackIndex: int, moveType: 'variant): int
 */

type movement =
  | Up
  | Right
  | Down
  | Left;

let getNextCursorPosition = (currentAttackIndex, moveType) => {
  switch (moveType) {
  | Up => currentAttackIndex + 2
  | Right => currentAttackIndex + 1
  | Down => currentAttackIndex - 2
  | Left => currentAttackIndex - 1
  };
};

//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................

/*
 * Whaaat, attacks do no damage ?!!
 * It's time to calculate how damage works ðŸ’ª
 * > Well, sometimes the attack misses you know ðŸ™ˆ
 *
 * Define getHpAfterDamage function with following signature ->
 *  (~currentHp: int, ~damage: option<int>): number
 */
let getHpAfterDamage = (~currentHp, ~damage) => {
  switch (damage) {
  | Some(damage) => currentHp - damage
  | None => currentHp
  };
};

//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................
//............................

/*
 * PokÃ©mon games are so much fun, and have so many different pokÃ©mons
 * We need to account for little pokÃ©mon types that we have defined
 * Supported types are Electric âš¡ï¸, Water ðŸ’¦, Psychic ðŸ’†â€â™€ï¸ and Normal ðŸ’ª
 *
 * Please define getDamageMultiplier function with following signature
 *  (attackType: pokemonType, defenceType: pokemonType): float
 */
type pokemonType =
  | Electric
  | Water
  | Psychic
  | Normal;

let getDamageMultiplier = (attackType, defenceType) => {
  let isSameType = attackType === defenceType;

  switch (attackType, defenceType, isSameType) {
  | (Electric, Water, false) => 2.0
  | (_, _, true) => 0.5
  | (_, _, _) => 1.0
  };
};
